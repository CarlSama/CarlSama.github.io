---
layout : post
time : 2015-4-16
title : SGI Stl的空间配置器的赏析
category : Stl
keywrods : Stl, Allocator
tags : Stl
description : 对SGI Stl中空间配置器的源码分析以及模仿实现
---

## 前言

毋庸置疑,C++ Stl对于每个C++成员来讲都是披荆斩棘的利器.

Stl中有经典算法,以及常用的容器.熟练的使用Stl中的这些组件可以为程序员们节省大量的重复劳作,帮助我们更多的集中精力于整体的设计.要想在编码过程中做到对Stl的高效使用,尝试去了解Stl的实现信息是必不可少的,更何况Stl中经典的C++编码风格也会让我们在阅读,分析源码的过程中获益匪浅.

本系列的博文是在我分析并临摹SGI STL源码,阅读侯捷先生的相关书籍的过程中的总结与思考,公布出来希望能够对读者有些帮助,也欢迎各位读者与我的讨论,指教.  ;)

## 空间配置器

空间配置器(allocator)是一切Stl容器的支撑,它默默的隐藏在背后,为各个容器的正确运行贡献这自己的一份力.

你一定能想到,最简单的allocator可以实现为单纯的对::operator new 和::operator delete的调用.这种方法自有其简洁的优点,但是当用户重复的进行内存的申请与释放时,这种un-cache的方法就显得低效了.在SGI STL中,实现了一个对未使用空间的链接表free_list,所有对空间的申请操作都是基于对free_list当前状态的分析而做出的.下面我们来具体的看一下.

## new 

对于有过C++编程经验的人来讲,运算符**new**肯定不会陌生,许多空间的分配都离不开它.**new**实际的执行效果可以分为两个阶段:	

1.	空间分配
2.	对象构造

如果我们希望将空间的分配与对象的构造过程分离,**operator new**和**placement new**绝对是我们要寻找的.关于这两个利器的介绍,你可以查看[这里](http://www.cplusplus.com/reference/new/operator%20new/?kw=operator%20new).关于使用方法我就不加赘述了.

这里我想讨论的是合理的使用**operator new**和**placement new**相比于单纯的使用**new**的优势.运算符**new**需要在系统heap中查找足够大的空间来提供给用户,这个过程可能很慢,并且会出现内存不足而导致失败的问题.使用**operator new**来分配公共内存后,**placement new**可以在这片准备好的内存上多次进行对象的构建.除了第一次,内存的分配是常数时间的,也不会出现内存不足的情况.非常适合对时间要求高,并且反复创建,销毁对象的程序.

## rebind

Allocator中有一个会令人感到"初次见面,请多指教"的function template, 叫做rebind.它的代码十分简短.
</br></br>
{% highlight C++ %}
template <typename U>
	struct rebind {
		typedef allocator<U> other;
	}
{% endhighlight %}
</br>

首先要注意的是整个STL框架中应用广泛的typedef体系,因为STL是基于泛型编程的,所以为了使用对象实际的类型,STL的实现者在许多template class中都定义了为数众多,但是有大同小异的typedef.这些typedef的定义为类型信息的传递起到了重要的作用.关于这方面的内容,我会在之后iterator章节的介绍中有更多介绍.

我在网上找到了一段关于rebind函数公用的介绍:
" A structure that enables an allocator for objects of one type to allocate storage for objects of another type"

## construct && destory

虽然consruct函数和destory函数属于allocator的一部分,我在临摹sgi stl时,仿照着sgi将本该在<memory>中的allocator内容,拆分为了三部分:

|Header       |Illustrate                  |
|:----:       |:--------:                  |
|allocator.h  |空间的申请与释放            |
|constructor.h|对象的创建与销毁            |
|memory.h     |在大块的内存空间上copy与fill|

首先来讲解一下constructor.h的内容.SGI STL极其追求效率,它会分析每个对象的特性,并依次来调用最合适的函数来进行处理,在我们之后越来越多的讲解中,你也一定会慢慢的理解并欣赏它的这种做法.话不说远,就然我们先来分析一下它的construct,destory方法.

在destory方法中,会根据对象的特征,选择是否需要调用对象的析构函数.对于不需要调用析构函数的情况,destory方法可以do nothing;而对于有必要调用析构函数的对象类型,destory方法会老老实实的依次调用区间内各个对象的析构方法,保证对象的安全析构.此外,泛型编程中还有[partial sepcialization](http://www.cprogramming.com/tutorial/template_specialization.html)这一利器来帮助我们处理特殊情况,

对象类型(value_type),以及其类型所包含的相关信息是通过iterator_traits和type_traits来获取的,我们会在之后更加详细的介绍到.

So, let's wait and see.

## allocator

终于到了令人激动的空间配置环节了.打起精神来听我慢慢讲, :)

在SGI STL中,包含两层的空间配置器.当处理大块内存请求时,会直接调用new和delete来完成(也就是first level allocator).而当遇到小内存请求时,则会使用second level allocator来完成.

网上有许多对SGI STL second level allocator的分析图例,侯捷的书中也对它有详细的介绍.我在这里就主要说一下我对它的一些理解.所以还未大致了解second level allocator的童鞋,请先移步到基础教学区,come back later :(

首先来讲,free_list是char* 的数组,数组中每个对象都指向了特定空间的unused memory所组成的single list.请求大小为m的空间时,如果其所对应的free_list[make_aligned(m)]项不为空,表明有unused memory可供使用,可以直接取来提供给用户.有时能够极大的提升多次小空间申请的效率.

其次,在每个single list中都使用了一个小技巧:
{% highlight C++ %}
union obj {
	union obj* free_list_link;
	char data[1];
	}
{% endhighlight %}
</br>
这或许会对一些童鞋带来困扰，我这就讲解下．这个结构体的使用是为了在每个unused memory中包含下个unused memory的地址,而第一个unused memory的地址当然就包含在free_list[n]中. 每次对unused memory的获取，都是先消耗首个空间，也就是free_list[n]指向的内容．
当single list中首个unused memory被取出时，它内部的free_list_link信息也就不再被需要，此时可以按照char datap[1]的视图来处理这块memory．

读者要是对这个技巧仍然抱有疑问的话，可以打印出这个结构体中free_list_link和data的首地址，你会发现它们都是指向相同的地址空间，也就是每个待使用的memory的起始处，这或许会对你的理解起到一定帮助．　：）


## Standard for allocator

根据STL规范,allocator应该包含一下的接口:

1.	value_type
2.	pointer
3.	const_pointer
4.	reference
5.	const_reference
6.	size_type
7.	difference_type
8.	rebing
9.	default constructor
10.	copy constructor
11.	destructor
12.	address
13.	allocate
14.	deallocate
15.	max_size
16.	construct
17.	destory
