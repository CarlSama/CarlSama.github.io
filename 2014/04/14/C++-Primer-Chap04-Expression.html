<p>---                                                                                 layout : post
time : 2014-4-14
title : C++ Primer -- Chap04
category : C++
keywrods : C++, C++ Primer
tags : C++</p>

<h2>description : my reading notes about C++ Primer chap 4</h2>

<h2>expression</h2>

<ul>
<li><p>对象被当做左值使用时,用的是内存中的位置;对象被当做右值只用时,用的是内容.</p></li>
<li><p>使用关键字decltype时:</p>

<blockquote><p>表达式求值结果为左值,decltype作用于该表达式得到引用类型: decltype(*p)
右值,非引用</p></blockquote></li>
</ul>


<h3>&amp;&amp; ||</h3>

<ul>
<li>short-cicut evaluation</li>
</ul>


<h3>关系运算符</h3>

<ul>
<li>左结合</li>
</ul>


<h3>赋值运算符</h3>

<ul>
<li>右结合</li>
</ul>


<h3>sizeof</h3>

<ul>
<li>面对数组和指针的差异.</li>
</ul>


<h3>逗号表达式</h3>

<ul>
<li>从左往右依次计算.</li>
</ul>


<h2>类型转换</h2>

<ul>
<li><p>无符号 &amp; 有符号类型不一致时</p>

<blockquote><p>无符号类型不小于有符号类型,转换为无符号类型.(unsigned int 和 int -> unsigned int)
无符号类型小于有符号类型,转换结果依赖于机器.(unsigned int 和 long long -> long long)</p></blockquote></li>
<li><p>显示类型转换</p></li>
</ul>


<p>static_cast<type-id>(expression)</p>

<p>没有运行时检查来保证转换的安全性</p>

<ol>
<li><p>基类指针转换为派生类指针</p></li>
<li><p>built-in type之间的转换</p>

<blockquote><p>告诉编译器我们不在意精度损失,关闭警告</p></blockquote></li>
<li><p>找回void指针或设置为void指针</p>

<blockquote><p>double * p = static_cast<double *>(void *)</p></blockquote></li>
</ol>


<p>dynamic_cast<type-id>(expression)</p>

<p>要求:type-id必须是指针,引用或者void*</p>

<ol>
<li><p>进行基类指针与派生类指针之间的转换(不同层)</p>

<blockquote><p>进行类型检查,比static_cast更安全
需要有虚函数(由于运行时检查需要运行时类型信息,这个信息存储在虚函数表中)</p></blockquote></li>
<li><p>同层之间的转换</p>

<blockquote><p>static_cast不允许
dynamic_cast结果为0</p></blockquote></li>
</ol>


<p>reinpreter_cast<type-id>(expression)</p>

<p>type-id必须是一个指针,引用,算数类型,函数指针或者成员指针.它可以在指针和整数之间转换,</p>

<p>const_cast<type-id>(expression)
去除const和volatile属性.type-id要为指针，引用．
可以去除底层const</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++">int j = 10;
const int * ptr = &amp;j;
(*(const_cast&lt;int*&gt;(i))) = 0;
cout&lt;&lt;j&lt;&lt;endl; // 0</code></pre></div>



